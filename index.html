<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¤šè¯­è¨€ Word Search H5ï¼ˆv3 Â· è‡³å°‘6è¯ Â· è‡ªåŠ¨è®¡æ—¶ï¼‰</title>
  <style>
    :root { --bg1:#f8fafc; --bg2:#eef2f7; --card:#fff; --text:#0f172a; --muted:#64748b; --accent:#4f46e5; --ok:#059669; --warn:#ef4444; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; color: var(--text); background: linear-gradient(to bottom, var(--bg1), var(--bg2)); }
    .container { max-width: 1120px; margin: 0 auto; padding: 24px; }
    h1 { font-size: 24px; margin: 0; font-weight: 800; letter-spacing: .2px; display: flex; align-items: center; gap: 8px; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    select, textarea, input { border: 1px solid #e5e7eb; border-radius: 12px; padding: 8px 12px; background: #fff; }
    button { border: 0; padding: 10px 14px; border-radius: 12px; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
    button.secondary { background: #e2e8f0; color: #0f172a; }
    button.ghost { background: transparent; color: var(--text); border: 1px solid #e5e7eb; }
    .grid-wrap { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; margin-top: 16px; }
    .card { background: var(--card); border-radius: 16px; box-shadow: 0 6px 20px rgba(15, 23, 42, .08); }
    .card-h { padding: 16px 16px 8px; font-weight: 700; display:flex; align-items:center; justify-content:space-between; }
    .card-c { padding: 16px; }
    .board { display: inline-grid; user-select: none; position: relative; }
    .overlay { position:absolute; inset:0; background: rgba(255,255,255,.6); backdrop-filter: blur(1px); border-radius: 12px; display:none; align-items:center; justify-content:center; font-weight:800; font-size:18px; color: var(--warn); }
    .cell { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; border: 1px solid #e5e7eb; font-weight: 700; border-radius: 8px; margin: 3px; background: rgba(255,255,255,.9); transition: background .12s ease, transform .05s; }
    .cell:hover { background: #f1f5f9; }
    .cell.drag { outline: 2px dashed #a5b4fc; outline-offset: -4px; }
    .word { display: flex; gap: 8px; align-items: center; padding: 6px 8px; border: 1px solid #e5e7eb; border-radius: 12px; background: #fff; }
    .word .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .word.found { background: #ecfdf5; border-color: #34d399; text-decoration: line-through; opacity:.85; }
    .status { display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap; }
    .muted { color: var(--muted); font-size: 13px; }
    .time { font-weight: 800; min-width: 68px; text-align: right; }
    .done { color: var(--ok); font-weight:700; }
    .timeup { color: var(--warn); font-weight:700; display:none; }
    .levelbar { display:flex; align-items:center; gap:8px; }
    .leveltag { background:#e2e8f0; color:#0f172a; padding:4px 10px; border-radius:999px; font-weight:700; }
    .cta { display:flex; gap:8px; align-items:center; }
    @media (max-width: 900px) { .grid-wrap { grid-template-columns: 1fr; } }

    /* Landing Screen */
    .landing { position: fixed; inset:0; display:flex; align-items:center; justify-content:center; background: radial-gradient(1200px 600px at 50% -10%, #fff 0, #eef2f7 60%, #e2e8f0 100%); z-index: 999; }
    .landing .panel { background:#ffffff; border:1px solid #e5e7eb; border-radius: 24px; padding: 24px; width: min(680px, 92vw); box-shadow: 0 20px 60px rgba(15, 23, 42, .12); }
    .landing h2 { margin: 0 0 12px 0; font-size: 28px; }
    .landing p { margin: 4px 0 16px 0; color: var(--muted); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .row > * { flex: 1 1 auto; }
    .panel .footer { display:flex; justify-content: flex-end; gap: 10px; margin-top: 16px; }
  </style>
</head>
<body>
  <!-- Landing Screen -->
  <div id="landing" class="landing">
    <div class="panel">
      <h2>ğŸ® Word Search æ‰¾è¯é—¯å…³</h2>
      <p>é€‰æ‹©è¯­è¨€ä¸é™æ—¶ï¼Œç‚¹å‡»ã€Œè¿›å…¥æ¸¸æˆã€å³å¼€å§‹é—¯å…³ä¸å€’è®¡æ—¶ã€‚</p>
      <div class="row">
        <label>è¯­è¨€ï¼š<select id="landingLanguage"></select></label>
        <label>é™æ—¶ï¼š
          <select id="landingTimer">
            <option value="60" selected>60 ç§’</option>
            <option value="120">120 ç§’</option>
            <option value="180">180 ç§’</option>
            <option value="0">ä¸é™</option>
          </select>
        </label>
      </div>
      <div class="row" style="margin-top:10px;">
        <label>èµ·å§‹å…³å¡ï¼š
          <select id="landingLevel">
            <option value="1" selected>ç¬¬ 1 å…³ï¼ˆ10Ã—10 / â‰¥6è¯ï¼‰</option>
            <option value="2">ç¬¬ 2 å…³ï¼ˆ12Ã—12 / â‰¥6è¯ï¼‰</option>
            <option value="3">ç¬¬ 3 å…³ï¼ˆ14Ã—14 / â‰¥6è¯ï¼‰</option>
            <option value="4">ç¬¬ 4 å…³ï¼ˆ16Ã—16 / â‰¥6è¯ï¼‰</option>
            <option value="5">ç¬¬ 5 å…³ï¼ˆ18Ã—18 / â‰¥6è¯ï¼‰</option>
          </select>
        </label>
      </div>
      <div class="footer">
        <button id="enterGame">è¿›å…¥æ¸¸æˆ â–¶</button>
      </div>
    </div>
  </div>

  <div class="container">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
      <h1>âœ¨ å¤šè¯­è¨€ Word Search H5ï¼ˆv3 Â· è‡³å°‘6è¯ Â· è‡ªåŠ¨è®¡æ—¶ï¼‰</h1>
      <div class="toolbar">
        <div class="levelbar">
          <span class="leveltag">å…³å¡ <span id="levelNo">1</span></span>
          <span class="muted">éš¾åº¦ï¼š<span id="levelDesc">10Ã—10 / â‰¥6è¯</span></span>
        </div>
        <label>è¯­è¨€ï¼š
          <select id="language"></select>
        </label>
        <div class="cta">
          <button id="regen">é‡å¼€æœ¬å…³</button>
          <button id="nextLevel" class="secondary" style="display:none;">ä¸‹ä¸€å…³ â–¶</button>
        </div>
        <span class="time muted">å‰©ä½™ <span id="timeLeft">--:--</span></span>
      </div>
    </div>

    <div class="grid-wrap">
      <div class="card">
        <div class="card-h">ç›˜é¢ <button id="resetBoard" class="ghost">é‡ç½®ç›˜é¢</button></div>
        <div class="card-c">
          <div style="position:relative; display:inline-block;">
            <div id="board" class="board"></div>
            <div id="boardOverlay" class="overlay">â° æ—¶é—´åˆ°</div>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="card">
          <div class="card-h">ç›®æ ‡è¯</div>
          <div class="card-c"><ul id="words" style="display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:8px;"></ul>
            <div class="muted" style="margin-top:8px;">æç¤ºï¼šæ”¯æŒæ­£å‘æˆ–åå‘é€‰ä¸­æ•´æ¡ç›´çº¿ï¼ˆæ°´å¹³/å‚ç›´/å¯¹è§’çº¿ï¼‰ã€‚</div>
          </div>
        </div>

        <div class="card" style="margin-top:16px;">
          <div class="card-h">è‡ªå®šä¹‰è¯è¡¨ï¼ˆå¯é€‰ï¼‰</div>
          <div class="card-c">
            <textarea id="custom" placeholder="ç”¨é€—å·æˆ–æ¢è¡Œåˆ†éš”ï¼Œä¾‹å¦‚ï¼šäººå·¥æ™ºèƒ½, è®¡ç®—æœºç¨‹åº, æœºå™¨å­¦ä¹ " style="width:100%; height:110px;"></textarea>
            <div style="display:flex; justify-content:flex-end; margin-top:8px;">
              <button id="useCustom" class="secondary">ç”¨è¯è¡¨ç”Ÿæˆ</button>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:16px;">
          <div class="card-h">çŠ¶æ€</div>
          <div class="card-c">
            <div class="status">
              <div class="muted">å·²æ‰¾åˆ°ï¼š<span id="foundCount">0</span> / <span id="totalCount">0</span></div>
              <div id="allDone" class="done" style="display:none;">å…¨éƒ¨æ‰¾åˆ°ï¼ğŸ‰</div>
              <div id="timeUp" class="timeup">æ—¶é—´åˆ° â°</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ===== å¤šè¯­è¨€å­—æ¯è¡¨ + è¯åº“ï¼ˆåŒ…å«è¾ƒé•¿è¯ï¼‰ =====
  const LANGUAGE_PACKS = {
    en: {
      label: "English",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),
      dictionary: [
        "MICROPROCESSOR","HYPERPARAMETER","CONFIGURATION","ALGORITHM","COMPUTER","PROGRAMMING","DATABASE","ARCHITECTURE","APPLICATION","DEVELOPMENT",
        "PHOTOGRAPHY","ASTRONOMY","BIODIVERSITY","MOUNTAINEER","WATERFALL","GREENHOUSE","ECOSYSTEM","CONTINENT","PENINSULA",
        "STRAWBERRY","BLUEBERRIES","PINEAPPLE","CHOCOLATE","CINNAMON",
        "APPLE","ORANGE","BANANA","GRAPE","MANGO","PEACH","CHERRY","LEMON",
        "JAVASCRIPT","REACT","KEYBOARD","SCREEN","MOBILE","SERVER","ROUTER",
        "RIVER","MOUNTAIN","OCEAN","FOREST","DESERT","ISLAND","VALLEY","PLAIN","HILL","LAKE",
      ],
    },
    zh: {
      label: "ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰",
      alphabet: "çš„ä¸€æ˜¯åœ¨ä¸äº†æœ‰å’Œäººè¿™ä¸­å¤§ä¸ºä¸Šä¸ªå›½æˆ‘ä»¥è¦ä»–æ—¶æ¥ç”¨ä»¬ç”Ÿåˆ°ä½œåœ°äºå‡ºå°±åˆ†å¯¹æˆä¼šå¯ä¸»å‘å¹´åŠ¨åŒå·¥ä¹Ÿèƒ½ä¸‹è¿‡å­è¯´äº§ç§é¢è€Œæ–¹åå¤šå®šè¡Œå­¦æ³•æ‰€æ°‘å¾—ç»åä¸‰ä¹‹è¿›ç€ç­‰éƒ¨åº¦å®¶ç”µåŠ›é‡Œå¦‚æ°´åŒ–é«˜è‡ªäºŒç†èµ·å°ç‰©ç°å®åŠ é‡éƒ½ä¸¤ä½“åˆ¶æœºå½“ä½¿ç‚¹ä»ä¸šæœ¬å»æŠŠæ€§å¥½åº”å¼€å®ƒåˆè¿˜å› ç”±å…¶äº›ç„¶å‰å¤–å¤©æ”¿å››æ—¥é‚£ç¤¾ä¹‰äº‹å¹³å½¢ç›¸å…¨è¡¨é—´æ ·ä¸å…³å„é‡æ–°çº¿å†…æ•°æ­£å¿ƒåä½ æ˜çœ‹åŸåˆä¹ˆåˆ©æ¯”æˆ–ä½†è´¨æ°”ç¬¬å‘é“å‘½æ­¤å˜æ¡åªæ²¡ç»“è§£é—®æ„å»ºæœˆå…¬æ— ç³»å†›å¾ˆæƒ…è€…æœ€ç«‹ä»£æƒ³å·²é€šå¹¶æç›´é¢˜å…šç¨‹å±•äº”æœæ–™è±¡å‘˜é©ä½å…¥å¸¸æ–‡æ€»æ¬¡å“å¼æ´»è®¾åŠç®¡ç‰¹ä»¶é•¿æ±‚è€å¤´åŸºèµ„è¾¹æµè·¯çº§å°‘å›¾å±±ç»Ÿæ¥çŸ¥è¾ƒå°†ç»„è§è®¡åˆ«å¥¹æ‰‹è§’æœŸæ ¹è®ºè¿å†œæŒ‡å‡ ä¹åŒºå¼ºæ”¾å†³è¥¿è¢«å¹²åšå¿…æˆ˜å…ˆå›åˆ™ä»»å–æ®å¤„é˜Ÿå—ç»™è‰²å…‰é—¨å³ä¿æ²»åŒ—é€ ç™¾è§„çƒ­é¢†ä¸ƒæµ·å£ä¸œå¯¼å™¨å‹å¿—ä¸–é‡‘å¢äº‰æµé˜¶æ²¹æ€æœ¯æäº¤å—è”ä»€è®¤å…­å…±æƒæ”¶è¯æ”¹æ¸…å·±ç¾å†é‡‡è½¬æ›´å•é£åˆ‡æ‰“ç™½æ•™é€ŸèŠ±å¸¦å®‰åœºèº«è½¦ä¾‹çœŸåŠ¡å…·ä¸‡æ¯ç›®è‡³è¾¾èµ°ç§¯ç¤ºè®®å£°æŠ¥æ–—å®Œç±»å…«ç¦»ååç¡®æ‰ç§‘å¼ ä¿¡é©¬èŠ‚è¯ç±³æ•´ç©ºå…ƒå†µä»Šé›†æ¸©ä¼ åœŸè®¸æ­¥ç¾¤å¹¿çŸ³è®°éœ€æ®µç ”ç•Œæ‹‰æ—å¾‹å«ä¸”ç©¶è§‚è¶Šç»‡è£…å½±ç®—ä½æŒéŸ³ä¼—ä¹¦å¸ƒå¤å®¹å„¿é¡»é™…å•†ééªŒè¿æ–­æ·±éš¾è¿‘çŸ¿åƒå‘¨å§”ç´ æŠ€å¤‡åŠåŠé’çœåˆ—ä¹ ä¾¿å“çº¦æ”¯èˆ¬å²æ„ŸåŠ³ä¾¿é£Ÿæ‰".split("") ,
      dictionary: [
        "äººå·¥æ™ºèƒ½","æœºå™¨å­¦ä¹ ","æ·±åº¦å­¦ä¹ ","è®¡ç®—æœºç¨‹åº","å›¾åƒè¯†åˆ«","è‡ªç„¶è¯­è¨€","ç¥ç»ç½‘ç»œ","å¤§æ•°æ®é›†","æ“ä½œç³»ç»Ÿ","åˆ†å¸ƒå¼ç½‘",
        "å¤ªç©ºæ¢ç´¢","ç”Ÿç‰©å¤šæ ·","ç¯å¢ƒä¿æŠ¤","å¯æŒç»­æ€§","é«˜ç­‰æ•°å­¦","é‡å­è®¡ç®—","è®¡ç®—æœºå›¾å½¢",
        "ç”µè„‘","æ‰‹æœº","å±å¹•","ç½‘ç»œ","ç¨‹åº","ç®—æ³•","æ•°æ®","æ¨¡å‹","æ¸¸æˆ","æœºå™¨äºº",
        "è‹¹æœ","é¦™è•‰","è‘¡è„","è¥¿ç“œ","æ¨±æ¡ƒ","èŠ’æœ","æŸ æª¬","æ¡ƒå­",
        "å±±è„‰","æ²³æµ","æ£®æ—","æ²™æ¼ ","æµ·æ´‹","æ¹–æ³Š","å¹³åŸ","å²›å±¿","å±±è°·","å¤©ç©º",
      ],
    },
    ja: {
      label: "æ—¥æœ¬èªï¼ˆã²ã‚‰ãŒãªï¼‰",
      alphabet: "ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚’ã‚“".split("") ,
      dictionary: [
        "ã“ã†ããã©ã†ã‚","ã§ã‚“ã—ã˜ã—ã‚‡","ã«ã»ã‚“ã”ãŒã","ã‘ã„ã–ã„ãŒã","ã˜ã‚‡ã†ã»ã†ãŒã",
        "ã‚Šã‚“ã”","ã¿ã‹ã‚“","ã„ã¡ã”","ã™ã„ã‹","ã•ãã‚‰","ã­ã“","ã„ã¬","ã‚„ã¾","ã‹ã‚","ã†ã¿","ã—ã¾","ãã‚‚","ã‹ãœ",
      ],
    },
    ko: {
      label: "í•œêµ­ì–´(í•œê¸€)",
      alphabet: "ê°€ë‚˜ë‹¤ë¼ë§ˆë°”ì‚¬ì•„ìì°¨ì¹´íƒ€íŒŒí•˜ê±°ë„ˆë”ëŸ¬ë¨¸ë²„ì¨ì–´ìš”ìœ ì´ì˜¤ë¬´ë°”ì‚¬ìì°¨ì¹´íƒ€íŒŒí•˜".split("") ,
      dictionary: [
        "ì¸ê³µì§€ëŠ¥","ê¸°ê³„í•™ìŠµ","ë”¥ëŸ¬ë‹","ìš´ì˜ì²´ì œ","ë°ì´í„°ë² ì´ìŠ¤","ìì—°ì–´ì²˜ë¦¬",
        "ì‚¬ê³¼","ë°”ë‚˜ë‚˜","í¬ë„","ë³µìˆ­ì•„","ìˆ˜ë°•","ë¼ë©´","ê¹€ì¹˜","ì‚°","ê°•","ë°”ë‹¤","ìˆ²","ì„¬","í•˜ëŠ˜",
      ],
    },
    es: {
      label: "EspaÃ±ol",
      alphabet: "ABCDEFGHIJKLMNÃ‘OPQRSTUVWXYZ".split("") ,
      dictionary: [
        "MICROPROCESADOR","CONFIGURACION","ALGORITMO","PROGRAMACION","APLICACION","DESARROLLO",
        "BIODIVERSIDAD","ASTRONOMIA","FOTOGRAFIA","CONTINENTE","PENINSULA",
        "FRAMBUESA","ARANDANOS","CHOCOLATE","CINAMONO",
        "MANZANA","NARANJA","PLATANO","PERA","UVA","MANGO","MELON","LIMON","CEREZA","FRESA",
        "RIO","MONTAÃ‘A","BOSQUE","DESIERTO","ISLA","LAGO","VALLE","CIELO","NUBE","VIENTO",
      ],
    },
  };

  const COLORS = ["#fde68a","#bbf7d0","#93c5fd","#fca5a5","#c4b5fd","#fdba74","#86efac","#a5b4fc","#f9a8d4","#7dd3fc","#fecaca","#d9f99d","#99f6e4","#f5d0fe","#fef08a","#d1fae5","#c7d2fe"];

  const DIRECTIONS = [
    { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
    { dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: -1, dy: -1 },
  ];

  function levelPreset(level) {
    if (level <= 1) return { size: 10, words: 6 };
    if (level === 2) return { size: 12, words: 8 };
    if (level === 3) return { size: 14, words: 10 };
    if (level === 4) return { size: 16, words: 12 };
    return { size: 18, words: 14 };
  }

  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const choice = (arr) => arr[randInt(0, arr.length - 1)];
  const normalize = (str) => (/^[A-Za-zÃ‘Ã±]+$/.test(str) ? str.toUpperCase() : str);

  // æ„å»ºå€™é€‰è¯ï¼ˆä¼˜å…ˆçŸ­è¯ï¼Œå…è®¸å°‘é‡é•¿è¯ï¼›è¿‡æ»¤æ‰é•¿åº¦ > grid size çš„è¯ï¼‰
  function buildCandidates(dict, expected, size) {
    const filtered = dict.filter(w => w.length <= size);
    const sorted = [...filtered].sort((a,b)=>a.length-b.length); // çŸ­åˆ°é•¿
    const longTail = filtered.filter(w => w.length > Math.max(5, Math.floor(size*0.7)));
    // æ‹¿å‰ expected*2 ä¸ªçŸ­è¯ + å°‘é‡é•¿è¯ï¼ˆæœ€å¤š expectedï¼‰æ··åˆ
    const shortPick = sorted.slice(0, Math.min(sorted.length, expected*2));
    // æ‰“ä¹±
    for (let i = shortPick.length - 1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [shortPick[i], shortPick[j]] = [shortPick[j], shortPick[i]]; }
    const longPick = longTail.slice(0, Math.min(longTail.length, expected));
    const merged = [...shortPick, ...longPick];
    // å»é‡
    return Array.from(new Set(merged)).map(normalize);
  }

  const cellsInLine = (x0, y0, x1, y1) => {
    const dx = Math.sign(x1 - x0);
    const dy = Math.sign(y1 - y0);
    const len = Math.max(Math.abs(x1 - x0), Math.abs(y1 - y0));
    if (!((dx === 0 || dy === 0) || Math.abs(x1 - x0) === Math.abs(y1 - y0))) return [];
    const out = [];
    for (let k = 0; k <= len; k++) out.push([x0 + dx * k, y0 + dy * k]);
    return out;
  };

  const createEmptyGrid = (size, fill = null) => Array.from({ length: size }, () => Array.from({ length: size }, () => fill));

  const canPlace = (grid, word, x, y, dir) => {
    const n = grid.length;
    for (let k = 0; k < word.length; k++) {
      const nx = x + dir.dx * k, ny = y + dir.dy * k;
      if (nx < 0 || ny < 0 || nx >= n || ny >= n) return false;
      const cell = grid[ny][nx];
      if (cell && cell.letter !== word[k]) return false;
    }
    return true;
  };

  const placeWord = (grid, word, dirOptions = DIRECTIONS) => {
    const n = grid.length; const dirs = [...dirOptions];
    for (let attempt = 0; attempt < 400; attempt++) {
      const dir = choice(dirs); const x = randInt(0, n - 1); const y = randInt(0, n - 1);
      if (!canPlace(grid, word, x, y, dir)) continue;
      const positions = [];
      for (let k = 0; k < word.length; k++) {
        const nx = x + dir.dx * k, ny = y + dir.dy * k;
        positions.push([nx, ny]);
        if (!grid[ny][nx]) grid[ny][nx] = { letter: word[k], words: new Set([word]) };
        else { grid[ny][nx].letter = word[k]; grid[ny][nx].words.add(word); }
      }
      return positions;
    }
    return null;
  };

  const fillRandom = (grid, alphabet) => {
    const n = grid.length;
    for (let y = 0; y < n; y++) for (let x = 0; x < n; x++) if (!grid[y][x]) grid[y][x] = { letter: choice(alphabet), words: new Set() };
    return grid;
  };

  function generateBoard({ langKey, level, customWords }) {
    const { alphabet, dictionary } = LANGUAGE_PACKS[langKey];
    const preset = levelPreset(level);
    const size = preset.size;
    const expected = Math.max(6, preset.words);
    const grid = createEmptyGrid(size);

    let candidates;
    if (customWords && customWords.length > 0) {
      candidates = customWords.filter(w => w && w.length <= size).map(normalize);
    } else {
      candidates = buildCandidates(dictionary, expected, size);
    }

    const placements = {};
    const placedWords = [];
    // å°è¯•æ”¾ç½®ï¼Œç›´åˆ°è¾¾åˆ° expected æˆ–å€™é€‰è€—å°½ï¼›ä¸è¶³åˆ™è¡¥å……çŸ­è¯ç»§ç»­å°è¯•
    const tryPlace = (list) => {
      for (const w of list) {
        if (placedWords.length >= expected) break;
        if (placements[w]) continue;
        const pos = placeWord(grid, w);
        if (pos) { placements[w] = pos; placedWords.push(w); }
      }
    };

    tryPlace(candidates);

    if (placedWords.length < 6) {
      // å…œåº•ï¼šä»å­—å…¸é‡Œæ‹¿æœ€çŸ­çš„è¯è¡¥å……
      const shortest = [...dictionary].filter(w => w.length <= size).sort((a,b)=>a.length-b.length).map(normalize);
      tryPlace(shortest);
    }

    fillRandom(grid, alphabet);

    // é¢œè‰²ä¸ºæ¯ä¸ªå•è¯åˆ†é…å”¯ä¸€å€¼
    const colorMap = {};
    placedWords.forEach((w, i) => { colorMap[w] = COLORS[i % COLORS.length]; });

    return { grid, placements, selectedWords: placedWords, colorMap, size, words: placedWords.length };
  }

  // ===== UI & äº¤äº’ï¼ˆè‡ªåŠ¨è®¡æ—¶ + å…³å¡ + ç™»é™†ç•Œé¢ï¼‰ =====
  const els = {
    // landing
    landing: document.getElementById('landing'),
    landingLanguage: document.getElementById('landingLanguage'),
    landingTimer: document.getElementById('landingTimer'),
    landingLevel: document.getElementById('landingLevel'),
    enterGame: document.getElementById('enterGame'),
    // in-game
    levelNo: document.getElementById('levelNo'),
    levelDesc: document.getElementById('levelDesc'),
    language: document.getElementById('language'),
    timeLeft: document.getElementById('timeLeft'),
    regen: document.getElementById('regen'),
    nextLevel: document.getElementById('nextLevel'),
    resetBoard: document.getElementById('resetBoard'),
    board: document.getElementById('board'),
    boardOverlay: document.getElementById('boardOverlay'),
    words: document.getElementById('words'),
    custom: document.getElementById('custom'),
    useCustom: document.getElementById('useCustom'),
    foundCount: document.getElementById('foundCount'),
    totalCount: document.getElementById('totalCount'),
    allDone: document.getElementById('allDone'),
    timeUp: document.getElementById('timeUp'),
  };

  // å¡«å……è¯­è¨€é€‰æ‹©ï¼ˆç™»é™†é¡µ & æ¸¸æˆå†…ï¼‰
  function populateLanguages(selectEl, defaultKey='en') {
    selectEl.innerHTML = '';
    for (const k of Object.keys(LANGUAGE_PACKS)) {
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = LANGUAGE_PACKS[k].label; if (k === defaultKey) opt.selected = true;
      selectEl.appendChild(opt);
    }
  }
  populateLanguages(els.landingLanguage, 'en');
  populateLanguages(els.language, 'en');

  let state = {
    level: 1, langKey: 'en', board: null, found: new Set(), drag: null,
    timeLimit: 60, timeLeft: 0, timer: null, active: false
  };

  function presetToText(level) {
    const p = levelPreset(level);
    return `${p.size}Ã—${p.size} / â‰¥6è¯`;
  }

  function formatTime(s) {
    if (s <= 0) return "00:00";
    const m = Math.floor(s / 60).toString().padStart(2, '0');
    const ss = (s % 60).toString().padStart(2, '0');
    return `${m}:${ss}`;
  }

  function clearTimer() { if (state.timer) { clearInterval(state.timer); state.timer = null; } }
  function resetTimerUI() {
    els.timeLeft.textContent = state.timeLimit > 0 ? formatTime(state.timeLimit) : "--:--";
    els.boardOverlay.style.display = 'none'; els.timeUp.style.display = 'none';
  }

  function startCountdown() {
    clearTimer();
    if (state.timeLimit <= 0) { state.active = true; els.timeLeft.textContent = "--:--"; return; }
    state.timeLeft = state.timeLimit; els.timeLeft.textContent = formatTime(state.timeLeft);
    state.active = true;
    state.timer = setInterval(() => {
      state.timeLeft -= 1; els.timeLeft.textContent = formatTime(state.timeLeft);
      if (state.timeLeft <= 0) { clearTimer(); state.active = false; els.boardOverlay.style.display = 'flex'; els.timeUp.style.display = 'block'; }
    }, 1000);
  }

  function stopGameIfFinished() {
    if (state.found.size === state.board.selectedWords.length && state.board.selectedWords.length > 0) {
      els.allDone.style.display = 'block'; els.nextLevel.style.display = 'inline-block';
      clearTimer(); state.active = false;
    } else {
      els.allDone.style.display = 'none'; els.nextLevel.style.display = 'none';
    }
  }

  function rebuild(customWords) {
    state.board = generateBoard({ langKey: state.langKey, level: state.level, customWords });
    state.found = new Set();
    render();
    clearTimer(); state.active = false; resetTimerUI();
    els.levelNo.textContent = state.level;
    els.levelDesc.textContent = presetToText(state.level);
    // è‡ªåŠ¨å¼€å§‹å€’è®¡æ—¶
    startCountdown();
  }

  function render() {
    const n = state.board.grid.length;
    els.board.style.gridTemplateColumns = `repeat(${n}, 2.2rem)`;
    els.board.style.gridTemplateRows = `repeat(${n}, 2.2rem)`;

    // æ„å»ºæ ¼å­
    els.board.innerHTML = '';
    for (let y = 0; y < n; y++) {
      for (let x = 0; x < n; x++) {
        const cell = state.board.grid[y][x];
        const div = document.createElement('div');
        div.className = 'cell';
        div.textContent = cell.letter;
        div.dataset.x = x; div.dataset.y = y;
        div.onpointerdown = (e) => { e.preventDefault(); if (!state.active) return; startDrag(x, y); };
        div.onpointerenter = (e) => { if (e.buttons === 1 && state.active) moveDrag(x, y); };
        els.board.appendChild(div);
      }
    }

    // è¯è¡¨
    els.words.innerHTML = '';
    for (const w of state.board.selectedWords) {
      const li = document.createElement('li');
      li.className = 'word';
      const dot = document.createElement('span');
      dot.className = 'dot'; dot.style.background = state.board.colorMap[w];
      const txt = document.createElement('span'); txt.textContent = w;
      li.appendChild(dot); li.appendChild(txt);
      li.dataset.word = w;
      els.words.appendChild(li);
    }

    els.foundCount.textContent = 0;
    els.totalCount.textContent = state.board.selectedWords.length;
    els.allDone.style.display = 'none';
    els.nextLevel.style.display = 'none';

    // æ‹–é€‰ç»“æŸ
    els.board.onpointerup = () => { if (state.active) endDrag(); };
  }

  function cellsToString(cells) { return cells.map(([cx, cy]) => state.board.grid[cy][cx].letter).join(''); }

  function highlight(cells, color, on, isDrag=false) {
    for (const [x, y] of cells) {
      const idx = y * state.board.grid.length + x;
      const el = els.board.children[idx];
      if (!el) continue;
      if (isDrag) el.classList.toggle('drag', on);
      else {
        if (on) { el.style.background = color; }
        else { el.style.background = 'rgba(255,255,255,.9)'; }
      }
    }
  }

  function startDrag(x, y) {
    state.drag = { start: [x, y], end: [x, y], cells: [[x, y]] };
    highlight(state.drag.cells, null, true, true);
  }

  function moveDrag(x, y) {
    if (!state.drag) return;
    const cells = cellsInLine(state.drag.start[0], state.drag.start[1], x, y);
    highlight(state.drag.cells, null, false, true);
    state.drag = { ...state.drag, end: [x, y], cells };
    highlight(state.drag.cells, null, true, true);
  }

  function endDrag() {
    if (!state.drag) return;
    const text = cellsToString(state.drag.cells);
    const rev = [...text].reverse().join('');
    for (const w of state.board.selectedWords) {
      if (!state.found.has(w) && (text === w || rev === w)) {
        state.found.add(w);
        const coords = state.board.placements[w];
        const color = state.board.colorMap[w];
        highlight(coords, color, true, false);
        const li = Array.from(els.words.children).find(li => li.dataset.word === w);
        if (li) li.classList.add('found');
      }
    }
    els.foundCount.textContent = state.found.size;
    stopGameIfFinished();

    // æ¸…ç†æ‹–é€‰é«˜äº®ï¼ˆä»…æ‹–æ‹½ä¸´æ—¶æ•ˆæœï¼‰
    highlight(state.drag.cells, null, false, true);
    state.drag = null;
  }

  // äº‹ä»¶ç»‘å®š
  els.language.addEventListener('change', (e) => { state.langKey = e.target.value; rebuild(); });
  els.resetBoard.addEventListener('click', () => { rebuild(); });
  els.regen.addEventListener('click', () => {
    const customWords = els.custom.value.split(/\n|,|;|\s+/).map(s=>s.trim()).filter(Boolean);
    rebuild(customWords.length ? customWords : undefined);
  });
  els.useCustom.addEventListener('click', () => {
    const customWords = els.custom.value.split(/\n|,|;|\s+/).map(s=>s.trim()).filter(Boolean);
    rebuild(customWords);
  });
  els.nextLevel.addEventListener('click', () => { state.level += 1; rebuild(); });

  // è¿›å…¥æ¸¸æˆï¼ˆç™»é™†é¡µç¡®è®¤åè‡ªåŠ¨å¼€å§‹å€’è®¡æ—¶ï¼‰
  function populateLanguages(selectEl, defaultKey='en') {
    selectEl.innerHTML = '';
    for (const k of Object.keys(LANGUAGE_PACKS)) {
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = LANGUAGE_PACKS[k].label; if (k === defaultKey) opt.selected = true;
      selectEl.appendChild(opt);
    }
  }
  // å·²åœ¨ä¸Šæ–¹å®šä¹‰å¹¶è°ƒç”¨ï¼Œæ­¤å¤„æ— éœ€é‡å¤

  document.getElementById('enterGame').addEventListener('click', () => {
    state.langKey = document.getElementById('landingLanguage').value;
    state.level = parseInt(document.getElementById('landingLevel').value, 10);
    state.timeLimit = parseInt(document.getElementById('landingTimer').value, 10);
    // åŒæ­¥åˆ°å†…é¡µçš„è¯­è¨€é€‰æ‹©
    document.getElementById('language').value = state.langKey;
    document.getElementById('landing').style.display = 'none';
    rebuild();
  });

  // åˆå§‹åŒ–ï¼ˆåœç•™åœ¨ç™»é™†é¡µï¼‰
  els.timeLeft.textContent = "--:--";
  </script>
</body>
</html>
